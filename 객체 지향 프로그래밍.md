# 객체 지향 프로그래밍

---

## 📄 페이지 소개

---

- 객체 지향 언어에 대해 이해하고, 객체 지향적 프로그래밍을 알기 위해 만들었습니다.
- 게임 개발에서는 코딩 실력만이 전부는 아니지만 유니티는 C#으로 다룰 수 있으니 배워두면 효율적인 코드 작성에 조금의 도움이 될 것 입니다.

## ⏩ 절차 지향 프로그래밍

---

- 절차 지향은 이름에서부터 알 수 있듯이 **절차가 중요한 언어**이다.
- 절차 지향 프로그래밍은 프로그램의 진행 순서가 위에서부터 아래이며 **각 요소들이 유기적으로 연결되어야 한다.**
- C언어가 대표적인 절차 지향 언어이다.

```c
int Plus(int A)
{
	printf("1을 더합니다!\n");
	return A + 1;
}

int main()
{
	int a;
	scanf("%d", &a);
	printf("입력한 값은 %d입니다!\n", a);
	printf("%d", Plus(a));
}
```

- 보이는 코드는 C로 작성된 코드로, 각 변수의 선언과 함수 선언 등은 그 요소를 사용하기 위해 사용하는 명령어 위에 먼저 선언해두었다.
    - 만일 a라는 변수를 scanf 밑에 선언하거나 Plus 함수를 main 밑에서 선언한다면 그 코드는 오류가 나게 된다.
- 즉 C와 같은 절차 지향 프로그래밍은 **위에서부터 밑으로 절차적으로 프로그램을 실행**하는 방식이다.

### ⭕ 절차 지향의 장점

---

- 실행 속도가 빠르다.
- 컴퓨터의 처리구조와 비슷해 알고리즘의 이해가 쉽다.

---

### ❌ 절차 지향의 단점

---

- 유지 보수가 어렵다.
- 엄격한 순서 배정으로 인해 비효율적이다.
- ~~**대부분 틀딱 언어이다.**~~

---

## 🍵 객체 지향 프로그래밍

---

### 📦 객체

---

- 객체를 컴퓨터로 예를 들자면 **컴퓨터에 쓰이는 모든 부품과 기능들이 모두 객체**이다.
- **프로그램**에게 있어서 **객체란 기능을 가진 모든 요소들을 객체**라고 한다.

---

- 객체 지향 언어란 프로그램을 다수의 객체로 만들고 이들끼리 서로 상호작용하도록 만드는 프로그래밍 언어이다.
- 객체들 하나하나가 모두 프로그램에서 하나의 개념으로 인정받고 어디에 있는 그 존재가 다른 객체들에게도 보이게 된다.
    - 따라서 객체 지향 언어는 프로그램의 진행 순서가 불규칙적이고, 각 객체끼리의 상호작용이 중요하게 된다.
    - 비유하면 컴퓨터의 모든 부품을 적절히 연결하고 조립해서 컴퓨터가 제대로 작동하도록 만드는 것이다.
- 객체 지향은 C++, C#, JAVA, Python 등등 요즘 나온 **새삥** 언어들은 대부분 객체 지향 언어이다.

### ✨ 객체 지향 언어의 특징

---

- 객체 지향의 특징은 곧 객체 지향 프로그래밍의 규칙이기도 하다. 이러한 특징을 살린 코드를 **객체 지향적인 코드**라고 한다.
- **캡슐화**
    - 데이터와 알고리즘을 하나로 묶어 하나의 캡슐처럼 만드는 것이다.
    - 캡슐로 감싸져서 외부의 존재가 내가 작성한 프로그래밍을 알 수 없다.
    - 캡슐화는 객체 지향적 프로그래밍의 일종의 룰이다.
- **상속**
    - 부모가 자식에게 유전자를 물려주듯, 상위 클래스의 모든 것을 하위 클래스가 이어받는 것이다.
    - 객체끼리의 상호작용을 보여주는 단적인 예시로 상속을 이해한다면 객체지향의 느낌을 얼추 알 수 있다.
- **다형성**
    - 상속과 연관된 개념으로, 하나의 객체가 다른 여러 객체로 재구성 되는 것이다.
    - 상속을 받은 자식 객체는 부모 객체와 동일한 속성을 가지게 되지만 자식 개체만의 특징도 당연하게 남게됨으로 한 개체가 다양한 형태로 존재할 수 있게된다.
    - 함수 오버로드, 오버라이드가 다형성을 드러내는 예시가 된다.
- **추상화**
    - 실존하는 객체의 여러 특성 중, 프로그램을 만드는데 필요한 공통적인 부분만 파악해서 추출하고 불필요한 것을 제거하는 것이다.
    
    ---
    

### 📌 객체 지향 5원칙: SOLID

---

- 또한 객체 지향은 다음과 같은 5가지의 규칙을 따라야한다.
- **단일 책임 원칙**(Single responsibility principle) : SRP
    - 모든 **클래스는 각각 단 하나만의 기능을 전담해 수행**해야 하는 원칙.
    - 이는 응집도를 높이고 결합도를 낮추어 객체의 특징을 잘 살릴 수 있다.
- **개방 폐쇄 원칙**(Open/closed principle) : OCP
    - 변경이나 요구 사항이 와도 프로그램의 모든 요소들은 확장할 수 있어도 변경되선 안된다는 원칙.
    - 클래스를 설계할 때 변할 부분과 아닌 부분을 구분하여야 한다. 즉 **부모 클래스엔 상속받을 클래스들에게 꼭 필요한 정보만을 가져야 한다.**
- **리스코프 치환 원칙**(Liskov substitution principle) : LSP
    - 상속을 받은 **자식 클래스는 부모 클래스의 기능을 온전히 수행해야 하는 원칙**.
    - 주로 자식 클래스를 오버라이드(재정의) 하면서 이 원칙을 잃기 쉽기에 오버라이드를 하지 않을수록 좋다.  오버라이드는 신중히 하자.
- **인터페이스 분리 원칙**(Interface segregation principle) : ISP
    - 자신이 사용하지 않는 인터페이스는 구현하지 않는다는 원칙.
    - **개별적이고 구체적인 인터페이스를 작은 단위로 구현**하는 것이 좋다.
- **의존관계 역전 원칙**(Dependency inversion principle) : DIP
    - 상속관계에 의해 구체적인 클래스를 사용하거나 의존하지 말고, 최대한 추상화한 클래스에 의존하라는 원칙.
    - 인터페이스를 적극적으로 활용해서 클래스 사이의 의존관계보다 추상화한 클래스에 의존하라는 의미이다.
    - 이해하기 어렵다면 모든 기능을 한 클래스에 모아넣고 사용하기보다 **상속을 사용하여 의존관계가 추상적이게 되고, 코드의 수정이 쉬워지도록** **해야한다**고 이해하면 충분하다.-
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20438186dd975b4e3296accbd1435338d8/Untitled.png)
    
    ![Untitled](%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%20%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20438186dd975b4e3296accbd1435338d8/Untitled%201.png)
    

---

### ⭕ 객체 지향의 장점

---

- 상속이 가능하기에 코드의 재사용이 가능하다.
- 각각의 객체가 독립적으로 존재하기에 유지 및 보수가 편리해 생산성이 증가한다.
- 객체는 세상의 존재하는 것들과 비슷한 개념이기에 우리가 익숙해서 개발자의 생각대로 자연스럽게 구현할 수 있다.

---

### ❌ 객체 지향의 단점

---

- 객체의 역할과 기능을 이해해야되서 개발 시간이 오래걸린다.
- 컴퓨터의 처리 속도가 느리다.
- 객체의 특성을 다 이해해야하기 때문에 난이도가 비교적 높다.

---

### ❓ Class와 개체(Object)의 차이

---

- 객체 지향을 개념을 가볍게 알고 있는 사람이라면 클래스와 개체의 차이를 쉽게 받아들일 수 없을거다.
- 클래스와 개체의 차이를 설명하기 위해선 붕어빵의 예시를 자주 들곤 한다.
    - 붕어빵을 만들기 위해 필요한 것은 틀과 반죽물, 재료가 필요하다.
    - 여기서 붕어빵의 틀은 우리가 먹을 순 없지만 붕어빵을 만드는 결정적인 존재이고, 반죽물이 그 형태를 그대로 받은 뒤 재료들이 맛이라는 기능을 한다.
- 즉 틀(**클래스**)는 **직접 사용할 수 없는** 가상의 존재. 반죽물(**개체**)는 **그 형상을 본받은** 사용할 수 있는 실체적인 존재, 재료(**메서드**)는 그 안에서 **직접적인 기능을 수행하는** 요소이다.